//https://stackoverflow.com/questions/14183529/paint-method-draws-outside-jframe-if-first-coord-0-0


import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;

import javax.swing.*;

public class Grid extends JPanel implements KeyListener, ActionListener {

	private static int[] keys = {37, 38, 39, 40, 32};
	//L, rot, R, SD, HD
	
	public static final int WIDTH = 400;
	public static final int HEIGHT = WIDTH * 2;
	public static final int BOXSIZE = 30;
	public static final int ROWS = 20;
	public static final int COLS = 10;
	public static final int XMARGIN = (WIDTH - (COLS * BOXSIZE)) / 2;
	public static final int YMARGIN = (HEIGHT - (ROWS * BOXSIZE)) / 2;

	public static final Color LIGHTBLUE = new Color(3, 243, 241);
	public static final Color DARKBLUE = new Color (3, 0, 235);
	public static final Color ORANGE = new Color(246, 155, 1);
	public static final Color YELLOW = new Color(237, 242, 6);
	public static final Color GREEN = new Color (5, 239, 7);
	public static final Color PURPLE = new Color(164, 4, 229);
	public static final Color RED = new Color(234, 4, 4);

	private ArrayList<Tetromino> minos = new ArrayList<Tetromino>();
	private Tetromino currentMino;
	private TetrisArray array = new TetrisArray();

	int timerCount = 0;

	public static void main(String[] args) {
		JFrame f = new JFrame();
		f.setMinimumSize(new Dimension(WIDTH, HEIGHT));
		f.setResizable(false);
		Grid grid = new Grid();
		f.setContentPane(grid);	
		f.pack();
		f.addKeyListener(grid);
		f.setVisible(true);
		grid.setCurrentMino(new Tetromino());
		grid.setUpTimer();
	}

	public void setUpTimer() {
		Timer timer = new Timer(10, this);
		timer.setInitialDelay(10);
		timer.start();
	}

	public void setCurrentMino(Tetromino mino) {
		currentMino = mino;
	}

	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		g.drawString("Tetris", WIDTH / 3, YMARGIN / 2);
		drawGrid(g);
		drawMino(g, currentMino);
		drawFromArray(g);
	}

	public void drawGrid(Graphics g) {
		g.setColor(Color.BLACK);
		for (int c = 0; c < COLS; c++) {
			for (int r = 0; r < ROWS; r++) {
				g.drawRect((c * BOXSIZE) + XMARGIN, (r * BOXSIZE) + YMARGIN, BOXSIZE, BOXSIZE);
			}
		}
	}

	public void drawBox(Graphics g, Color c, int row, int col) {
		int xPos = XMARGIN + (col * BOXSIZE);
		int yPos = YMARGIN + (row * BOXSIZE);
		g.setColor(c);
		g.fillRect(xPos + 1, yPos + 1, BOXSIZE - 1, BOXSIZE - 1);
	}

	public void drawMino(Graphics g, Tetromino t) {
		int[][] pos = t.getPos();
		for (int[] coord : pos) {
			drawBox(g, t.getShape().getColor(), coord[0], coord[1]);
		}
	}

	public void drawFromArray(Graphics g) {
		for (int r = 0; r < ROWS; r++) {
			for (int c = 0; c < COLS; c++) {
				Point p = array.getPoint(r, c);
				if (p != Point.EMPTY && p != Point.CURRMINO) {
					drawBox(g, p.getColor(), r, c);
				}				
			}
		}
	}

	public void newMino() {
		addSetMinoPoints();
		for (int[] coord : currentMino.getPos()) {
			array.setPoint(coord[0], coord[1], currentMino.getSetMino());
		}
		currentMino = new Tetromino();
		currentMino.setInitialPos();
		System.out.print("new mino set pos ");
		System.out.println(currentMino.getPos());
		repaint();
	}

	public void keyPressed(KeyEvent e) {
		//System.out.println(e.toString());
		int keyInt = e.getKeyCode();
		boolean onLeftEdge = false;
		boolean onRightEdge = false;
		boolean atBottom = false;
		boolean collideLeft = false;
		boolean collideRight = false;

		for (int[] coord : currentMino.getPos()) {
			int row = coord[0];
			int col = coord[1];
			if (col == 0)
				onLeftEdge = true;
			else if (col == COLS - 1)
				onRightEdge = true;
			if (row == ROWS - 1)
				atBottom = true;
			if (!onLeftEdge && array.checkCollision(currentMino, TetrisArray.LEFT)) {
				collideLeft = true;
			}
			if (!onRightEdge && array.checkCollision(currentMino, TetrisArray.RIGHT)) {
				collideRight = true;
			}
		}

		//left
		if (keyInt == keys[0] && !collideLeft && !onLeftEdge) {
			currentMino.changePos(0, -1);
		}

		/*else if (keyInt == keys[1]) {
			currentMino.rotate();
		}*/

		//right
		else if (keyInt == keys[2] && !collideRight && !onRightEdge) {
			currentMino.changePos(0, 1);
			//System.out.println("move right");
		}

		//down
		else if (keyInt == keys[3] && !array.checkCollision(currentMino, TetrisArray.BELOW) && !atBottom) {
			currentMino.changePos(1, 0);
			//System.out.println("move down");
		}

		//space
		else if (keyInt == keys[4]) {
			hardDrop();
			newMino();
		}
		repaint();
	}

	public void keyReleased(KeyEvent arg0) {
	}

	public void keyTyped(KeyEvent arg0) {
	}

	public void hardDrop() {
		int[] minoLowest = currentMino.getLowestCoord();
		int minoLowestRow = minoLowest[0];
		System.out.println("lowest row: " + minoLowestRow);
		int rowsToDrop = 0;
		
		for (int[] coord : currentMino.getPos()) {
			if (coord[0] == minoLowestRow) {
				if (!array.colHasPoint(minoLowest[1])) {
					System.out.println("doesn't have point in col");
					rowsToDrop = Grid.ROWS - minoLowestRow - 1;
				}
				else {
					int rowToCheck = minoLowestRow;
					while (rowToCheck < Grid.ROWS && rowsToDrop == 0) {
						if (array.hasPointAt(rowToCheck, minoLowest[1])) {
							rowsToDrop = rowToCheck - minoLowestRow - 1;
						}
						else {
							rowToCheck++;
						}
					}
				}
			}
		}
		currentMino.changePos(rowsToDrop, 0);
	}

	public void removeCurrentMinoPoints() {
		for (int[] coord : currentMino.getPos()) {
			array.setPoint(coord[0], coord[1], Point.EMPTY);
		}
	}
	
	public void addCurrentMinoPoints() {
		for (int[] coord : currentMino.getPos()) {
			array.setPoint(coord[0], coord[1], Point.CURRMINO);
		}
	}

	public void addSetMinoPoints() {
		for (int[] coord : currentMino.getPos()) {
			Point setPoint = null;
			for (Point p : Point.getSetMinoList()) {
				if (p.getColor() == currentMino.getShape().getColor()) {
					setPoint = p;
				}
			}
			array.setPoint(coord[0], coord[1], setPoint);
		}
	}
	
	public void actionPerformed(ActionEvent arg0) {
		timerCount++;
		
		if (timerCount % 100 == 0) {
			timerCount = 0;
			boolean collides = array.checkCollision(currentMino, TetrisArray.BELOW);
			if (!currentMino.atBottom() && !collides) {
				removeCurrentMinoPoints();
				currentMino.changePos(1, 0);
				addCurrentMinoPoints();
			}
			
			if (currentMino.atBottom() || collides){
				System.out.println("at bottom");
				newMino();
			}
		}	
		
		repaint();
	}
}

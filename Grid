import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.Arrays;

import javax.swing.*;

public class Grid extends JPanel implements KeyListener, ActionListener {

	private static int[] thombusKeys = {KeyEvent.VK_LEFT, KeyEvent.VK_RIGHT, KeyEvent.VK_DOWN, KeyEvent.VK_SPACE, KeyEvent.VK_UP, KeyEvent.VK_CONTROL};
	private static int[] heblenKeys = {KeyEvent.VK_LEFT, KeyEvent.VK_RIGHT, KeyEvent.VK_DOWN, KeyEvent.VK_SPACE, KeyEvent.VK_X, KeyEvent.VK_Z};
	private static int[] leftKeys = {KeyEvent.VK_G, KeyEvent.VK_J, KeyEvent.VK_H, KeyEvent.VK_SPACE, KeyEvent.VK_Z, KeyEvent.VK_X};
	private static int[] rightKeys = {KeyEvent.VK_1, KeyEvent.VK_5, KeyEvent.VK_3, KeyEvent.VK_2, KeyEvent.VK_ALT, KeyEvent.VK_CONTROL};
	//L, R, SD, HD, rotCW, rotCCW

	public static final int WIDTH = 500;
	public static final int HEIGHT = 800;
	public static final int BOXSIZE = 30;
	public static final int ROWS = 20;
	public static final int COLS = 10;
	public static final int XMARGIN = (WIDTH - (COLS * BOXSIZE)) / 2;
	public static final int YMARGIN = (HEIGHT - (ROWS * BOXSIZE)) / 2;
	public static final int GRIDXMARGIN = XMARGIN / 4;
	public static final int NEXTGRIDXMARGIN = (2 * GRIDXMARGIN) + (BOXSIZE * COLS);
	public static final int NEXTBOXBIGSIZE = 3 * BOXSIZE;
	public static final int NEXTBOXSIZE = 3 * (BOXSIZE / 5);
	public static final Color LIGHTBLUE = new Color(3, 243, 241);
	public static final Color DARKBLUE = new Color (3, 0, 235);
	public static final Color ORANGE = new Color(246, 155, 1);
	public static final Color YELLOW = new Color(237, 242, 6);
	public static final Color GREEN = new Color (5, 239, 7);
	public static final Color PURPLE = new Color(164, 4, 229);
	public static final Color RED = new Color(234, 4, 4);

	private int[] keys = heblenKeys;
	private ArrayList<Tetromino> nextMinos = new ArrayList<Tetromino>();
	private Tetromino currentMino;
	private TetrisArray array = new TetrisArray();
	
	boolean waitTick;

	public Grid() {
		for (int i = 0; i < 6; i++) {
			addNextMino(new Tetromino(array));
		}
		setCurrentMino(nextMinos.remove(0));
		currentMino.setInitialPos();
		setUpTimer();
	}

	public static void singlePlayerSetup(Grid player) {
		JFrame f = new JFrame();
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.setMinimumSize(new Dimension(WIDTH, HEIGHT));
		f.add(player);
		f.setResizable(false);
		f.pack();
		f.addKeyListener(player);
		f.setVisible(true);
	}
	
	public static void twoPlayerSetup(Grid p1, Grid p2) {
		JFrame f = new JFrame();
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.setMinimumSize(new Dimension(2 * WIDTH, HEIGHT));
		f.setLayout(new BoxLayout(f.getContentPane(), BoxLayout.X_AXIS));
		f.add(p1);
		f.add(p2);
		f.setResizable(false);
		f.pack();
		f.addKeyListener(p1);
		f.addKeyListener(p2);
		f.setVisible(true);
	}
	
	public static void main(String[] args) {	
		twoPlayerSetup(new Grid(), new Grid());
	}
	

	public void setUpTimer() {
		Timer timer = new Timer(1000, this);
		timer.setInitialDelay(10);
		timer.start();
	}
	
	public void setKeys(int[] keyList) {
		keys = keyList;
	}

	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		g.drawString("Tetris", WIDTH / 3, YMARGIN / 2);
		drawGrid(g);
		drawNextGrid(g);
		drawNextMinos(g);
		if (!currentMino.atBottom()) {
			drawGhostPiece(g);
		}
		drawCurrentMino(g);
		drawFromArray(g);
	}

	public void drawGrid(Graphics g) {	
		for (int c = 0; c < COLS; c++) {
			for (int r = 0; r < ROWS; r++) {
				drawBox(g, Color.DARK_GRAY, r, c);
				g.setColor(Color.BLACK);
				g.drawRect((c * BOXSIZE) + GRIDXMARGIN, (r * BOXSIZE) + YMARGIN, BOXSIZE, BOXSIZE);
			}
		}
	}

	public void drawNextGrid(Graphics g) {
		int size = NEXTBOXBIGSIZE;
		for (int r = 0; r < 5; r++) {
			g.setColor(Color.DARK_GRAY);
			g.fillRect(NEXTGRIDXMARGIN, (r * size) + YMARGIN, size, size);
			g.setColor(Color.BLACK);
			g.drawRect(NEXTGRIDXMARGIN, (r * size) + YMARGIN, size, size);
		}
	}

	public void drawBox(Graphics g, Color c, int row, int col) {
		int xPos = GRIDXMARGIN + (col * BOXSIZE);
		int yPos = YMARGIN + (row * BOXSIZE);
		g.setColor(c);
		g.fillRect(xPos + 1, yPos + 1, BOXSIZE - 1, BOXSIZE - 1);
	}
	
	public void drawNextBox(Graphics g, Color c, int index, int row, int col) {
		int bigSize = NEXTBOXBIGSIZE;
		int smolSize = NEXTBOXSIZE;
		int xPos = NEXTGRIDXMARGIN + (col * smolSize) + smolSize;
		int xShift = 0;
		int yPos = YMARGIN + (row * smolSize) + (BOXSIZE * 3 * index) + smolSize;
		int yShift = 0;
		Color iColor = TetrominoShape.I.getColor();
		Color oColor = TetrominoShape.O.getColor();
		Color lColor = TetrominoShape.L.getColor();
		Color jColor = TetrominoShape.J.getColor();
		g.setColor(c);
		if (c.equals(iColor)) {
			xShift = -1 * (smolSize / 2);
		}
		else if (c.equals(oColor) || c.equals(lColor) || c.equals(jColor)) {
			xShift = smolSize / 2;
		}
		if (!(c.equals(lColor) || c.equals(jColor) || c.equals(iColor))) {
			yShift = smolSize / 2;
		}
		else if (c.equals(iColor)) {
			yShift = smolSize;
		}
		g.fillRect(xPos + 1 + xShift, yPos + 1 + yShift, smolSize - 1, smolSize - 1);
	}

	
	public void drawNextMinos(Graphics g) {	
		for (int i = 0; i < nextMinos.size(); i++) {
			Tetromino mino = nextMinos.get(i);
			for (int[] coords : mino.getPos()) {
				int[][] pos = mino.getPos();
				for (int[] coord : pos) {
					drawNextBox(g, mino.getShape().getColor(), i, coord[0], coord[1]);
				}
			}
		}
	}
	
	public void drawGhostPiece(Graphics g) {
		g.setColor(Color.LIGHT_GRAY);
		
		int[][] pos = new int[4][2];
		for (int i = 0; i < pos.length; i++) {
			for (int j = 0; j < pos[0].length; j++) {
				pos[i][j] = currentMino.getPos()[i][j];
			}
		}
		while (!Tetromino.atBottom(pos) && !array.checkCollision(pos, TetrisArray.BELOW)) {
			for (int[] coords : pos) {
				coords[0]++;
			}
		}

		for (int[] coords : pos) {
			g.drawRect((coords[1] * BOXSIZE) + GRIDXMARGIN, (coords[0] * BOXSIZE) + YMARGIN, BOXSIZE, BOXSIZE);
			//drawBox(g, Color.LIGHT_GRAY, coords[0], coords[1]);
		}
	}

	public void drawCurrentMino(Graphics g) {
		int[][] pos = currentMino.getPos();
		for (int[] coord : pos) {
			drawBox(g, currentMino.getShape().getColor(), coord[0], coord[1]);
		}
	}

	public void drawFromArray(Graphics g) {
		for (int r = 0; r < ROWS; r++) {
			for (int c = 0; c < COLS; c++) {
				Point p = array.getPoint(r, c);

				if (p != Point.EMPTY && p != Point.CURRMINO) {
					drawBox(g, p.getColor(), r, c);
				}				
			}
		}
	}
	
	public void setCurrentMino(Tetromino mino) {
		currentMino = mino;
	}

	public void addNextMino(Tetromino mino) {
		nextMinos.add(mino);
	}

	public void newMino() {
		Point setPoint = Point.SETMINOI;
		for (Point p : Point.getSetMinoList()) {
			if (p.getColor() == currentMino.getColor()) {
				setPoint = p;
			}
		}
		setCurrentMinoPoints(setPoint);
		currentMino = nextMinos.remove(0);
		addNextMino(new Tetromino(array));
		currentMino.setInitialPos();
		setCurrentMinoPoints(Point.CURRMINO);
		repaint();
	}

	public void keyPressed(KeyEvent e) {

		int keyInt = e.getKeyCode();
		boolean onLeftEdge = false;
		boolean onRightEdge = false;
		boolean atBottom = false;
		boolean collideLeft = false;
		boolean collideRight = false;

		setCurrentMinoPoints(Point.EMPTY);

		for (int[] coord : currentMino.getPos()) {
			int row = coord[0];
			int col = coord[1];
			if (col == 0)
				onLeftEdge = true;
			else if (col == COLS - 1)
				onRightEdge = true;
			if (row == ROWS - 1)
				atBottom = true;
			if (!onLeftEdge && array.checkCollision(currentMino, TetrisArray.LEFT)) {
				collideLeft = true;
			}
			if (!onRightEdge && array.checkCollision(currentMino, TetrisArray.RIGHT)) {
				collideRight = true;
			}
		}

		//L, R, SD, HD, rotCW, rotCCW

		//left
		if ((keyInt == keys[0] || keyInt == keys[0]) && !collideLeft && !onLeftEdge) {
			currentMino.changePos(0, -1);
		}


		//right
		else if (keyInt == keys[1] && !collideRight && !onRightEdge) {
			currentMino.changePos(0, 1);
			//System.out.println("move right");
		}

		//down
		else if ((keyInt == keys[2]) && !array.checkCollision(currentMino, TetrisArray.BELOW) && !atBottom) {
			currentMino.changePos(1, 0);
			//System.out.println("move down");
		}

		//space
		else if (keyInt == keys[3]) {
			hardDrop();
			newMino();
			array.clearLines();
			repaint();
		}

		//rotate cw
		else if (keyInt == keys[4]) {
			currentMino.rotateCW();
			System.out.println("cw");
		}

		//rotate ccw
		else if (keyInt == keys[5]) {
			currentMino.rotateCCW();
			System.out.println("ccw");
		}

		setCurrentMinoPoints(Point.CURRMINO);
		repaint();
	}

	public void keyReleased(KeyEvent arg0) {
	}

	public void keyTyped(KeyEvent arg0) {
	}

	public void hardDrop() {
		while (!currentMino.atBottom() && !array.checkCollision(currentMino, TetrisArray.BELOW)) {
			currentMino.changePos(1, 0);
		}
	}

	public void setCurrentMinoPoints(Point p) {
		for (int[] coord : currentMino.getPos()) {
			array.setPoint(coord[0], coord[1], p);
		}
	}

	public void actionPerformed(ActionEvent arg0) {
		boolean collides = array.checkCollision(currentMino, TetrisArray.BELOW);
		if (!currentMino.atBottom() && !collides) {
			setCurrentMinoPoints(Point.EMPTY);

			currentMino.changePos(1, 0);
			setCurrentMinoPoints(Point.CURRMINO);
		}


		//		array.print();
		//		System.out.println();


		if (waitTick && (currentMino.atBottom() || collides)) {
			newMino();
		}
		waitTick = false;
		if (currentMino.atBottom() || collides) {
			waitTick = true;
		}
		array.clearLines();

		repaint();
	}


	public static void print(int[][] array) {
		for (int[] i : array) {
			System.out.println(Arrays.toString(i));
		}
	}
}
